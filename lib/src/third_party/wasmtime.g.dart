// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint, unused_import
import 'dart:ffi' as ffi;

/// ////////////////////////////////////////////////////////////////////////////
@ffi.Native<ffi.Void Function(ffi.Pointer<wasm_config_t>)>()
external void wasm_config_delete(ffi.Pointer<wasm_config_t> arg0);

@ffi.Native<ffi.Pointer<wasm_config_t> Function()>()
external ffi.Pointer<wasm_config_t> wasm_config_new();

@ffi.Native<ffi.Void Function(ffi.Pointer<wasm_engine_t>)>()
external void wasm_engine_delete(ffi.Pointer<wasm_engine_t> arg0);

@ffi.Native<ffi.Pointer<wasm_engine_t> Function()>()
external ffi.Pointer<wasm_engine_t> wasm_engine_new();

@ffi.Native<ffi.Pointer<wasm_engine_t> Function(ffi.Pointer<wasm_config_t>)>()
external ffi.Pointer<wasm_engine_t> wasm_engine_new_with_config(
  ffi.Pointer<wasm_config_t> arg0,
);

/// \brief Increments the engine-local epoch variable.
///
/// This function will increment the engine's current epoch which can be used to
/// force WebAssembly code to trap if the current epoch goes beyond the
/// #wasmtime_store_t configured epoch deadline.
///
/// This function is safe to call from any thread, and it is also
/// async-signal-safe.
///
/// See also #wasmtime_config_epoch_interruption_set.
@ffi.Native<ffi.Void Function(ffi.Pointer<wasm_engine_t>)>()
external void wasmtime_engine_increment_epoch(
  ffi.Pointer<wasm_engine_t> engine,
);

/// \brief Returns whether this engine is using the Pulley interpreter to execute
/// WebAssembly code.
@ffi.Native<ffi.Bool Function(ffi.Pointer<wasm_engine_t>)>()
external bool wasmtime_engine_is_pulley(ffi.Pointer<wasm_engine_t> engine);

final class wasm_config_t extends ffi.Opaque {}

final class wasm_engine_t extends ffi.Opaque {}
