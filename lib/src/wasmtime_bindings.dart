// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint, unused_import
import 'dart:ffi' as ffi;

/// Bindings for wasmtime.
class WasmtimeBindings {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
  _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  WasmtimeBindings(ffi.DynamicLibrary dynamicLibrary)
    : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  WasmtimeBindings.fromLookup(
    ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName) lookup,
  ) : _lookup = lookup;

  void wasm_byte_vec_new_uninitialized(
    ffi.Pointer<wasm_byte_vec_t> out,
    int arg1,
  ) {
    return _wasm_byte_vec_new_uninitialized(out, arg1);
  }

  late final _wasm_byte_vec_new_uninitializedPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<wasm_byte_vec_t>, ffi.Size)
        >
      >('wasm_byte_vec_new_uninitialized');
  late final _wasm_byte_vec_new_uninitialized =
      _wasm_byte_vec_new_uninitializedPtr
          .asFunction<void Function(ffi.Pointer<wasm_byte_vec_t>, int)>();

  void wasm_byte_vec_delete(ffi.Pointer<wasm_byte_vec_t> arg0) {
    return _wasm_byte_vec_delete(arg0);
  }

  late final _wasm_byte_vec_deletePtr =
      _lookup<
        ffi.NativeFunction<ffi.Void Function(ffi.Pointer<wasm_byte_vec_t>)>
      >('wasm_byte_vec_delete');
  late final _wasm_byte_vec_delete = _wasm_byte_vec_deletePtr
      .asFunction<void Function(ffi.Pointer<wasm_byte_vec_t>)>();

  void wasm_engine_delete(ffi.Pointer<wasm_engine_t> arg0) {
    return _wasm_engine_delete(arg0);
  }

  late final _wasm_engine_deletePtr =
      _lookup<
        ffi.NativeFunction<ffi.Void Function(ffi.Pointer<wasm_engine_t>)>
      >('wasm_engine_delete');
  late final _wasm_engine_delete = _wasm_engine_deletePtr
      .asFunction<void Function(ffi.Pointer<wasm_engine_t>)>();

  ffi.Pointer<wasm_engine_t> wasm_engine_new() {
    return _wasm_engine_new();
  }

  late final _wasm_engine_newPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<wasm_engine_t> Function()>>(
        'wasm_engine_new',
      );
  late final _wasm_engine_new = _wasm_engine_newPtr
      .asFunction<ffi.Pointer<wasm_engine_t> Function()>();

  late final ffi.Pointer<ffi.Uint32> _wasm_limits_max_default =
      _lookup<ffi.Uint32>('wasm_limits_max_default');

  int get wasm_limits_max_default => _wasm_limits_max_default.value;

  late final ffi.Pointer<ffi.Size> _MEMORY_PAGE_SIZE = _lookup<ffi.Size>(
    'MEMORY_PAGE_SIZE',
  );

  int get MEMORY_PAGE_SIZE => _MEMORY_PAGE_SIZE.value;

  /// \brief Deletes an error.
  void wasmtime_error_delete(ffi.Pointer<wasmtime_error_t> error) {
    return _wasmtime_error_delete(error);
  }

  late final _wasmtime_error_deletePtr =
      _lookup<
        ffi.NativeFunction<ffi.Void Function(ffi.Pointer<wasmtime_error_t>)>
      >('wasmtime_error_delete');
  late final _wasmtime_error_delete = _wasmtime_error_deletePtr
      .asFunction<void Function(ffi.Pointer<wasmtime_error_t>)>();

  /// \brief Returns the string description of this error.
  ///
  /// This will "render" the error to a string and then return the string
  /// representation of the error to the caller. The `message` argument should be
  /// uninitialized before this function is called and the caller is responsible
  /// for deallocating it with #wasm_byte_vec_delete afterwards.
  void wasmtime_error_message(
    ffi.Pointer<wasmtime_error_t> error,
    ffi.Pointer<wasm_name_t> message,
  ) {
    return _wasmtime_error_message(error, message);
  }

  late final _wasmtime_error_messagePtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<wasmtime_error_t>,
            ffi.Pointer<wasm_name_t>,
          )
        >
      >('wasmtime_error_message');
  late final _wasmtime_error_message = _wasmtime_error_messagePtr
      .asFunction<
        void Function(ffi.Pointer<wasmtime_error_t>, ffi.Pointer<wasm_name_t>)
      >();

  /// \brief Converts from the text format of WebAssembly to the binary format.
  ///
  /// \param wat this it the input pointer with the WebAssembly Text Format inside
  /// of it. This will be parsed and converted to the binary format.
  /// \param wat_len this it the length of `wat`, in bytes.
  /// \param ret if the conversion is successful, this byte vector is filled in
  /// with the WebAssembly binary format.
  ///
  /// \return a non-null error if parsing fails, or returns `NULL`. If parsing
  /// fails then `ret` isn't touched.
  ///
  /// This function does not take ownership of `wat`, and the caller is expected to
  /// deallocate the returned #wasmtime_error_t and #wasm_byte_vec_t.
  ffi.Pointer<wasmtime_error_t> wasmtime_wat2wasm(
    ffi.Pointer<ffi.Char> wat,
    int wat_len,
    ffi.Pointer<wasm_byte_vec_t> ret,
  ) {
    return _wasmtime_wat2wasm(wat, wat_len, ret);
  }

  late final _wasmtime_wat2wasmPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Pointer<wasmtime_error_t> Function(
            ffi.Pointer<ffi.Char>,
            ffi.Size,
            ffi.Pointer<wasm_byte_vec_t>,
          )
        >
      >('wasmtime_wat2wasm');
  late final _wasmtime_wat2wasm = _wasmtime_wat2wasmPtr
      .asFunction<
        ffi.Pointer<wasmtime_error_t> Function(
          ffi.Pointer<ffi.Char>,
          int,
          ffi.Pointer<wasm_byte_vec_t>,
        )
      >();
}

typedef ptrdiff_t = ffi.Long;
typedef Dartptrdiff_t = int;

final class max_align_t extends ffi.Opaque {}

typedef __u_char = ffi.UnsignedChar;
typedef Dart__u_char = int;
typedef __u_short = ffi.UnsignedShort;
typedef Dart__u_short = int;
typedef __u_int = ffi.UnsignedInt;
typedef Dart__u_int = int;
typedef __u_long = ffi.UnsignedLong;
typedef Dart__u_long = int;
typedef __int8_t = ffi.SignedChar;
typedef Dart__int8_t = int;
typedef __uint8_t = ffi.UnsignedChar;
typedef Dart__uint8_t = int;
typedef __int16_t = ffi.Short;
typedef Dart__int16_t = int;
typedef __uint16_t = ffi.UnsignedShort;
typedef Dart__uint16_t = int;
typedef __int32_t = ffi.Int;
typedef Dart__int32_t = int;
typedef __uint32_t = ffi.UnsignedInt;
typedef Dart__uint32_t = int;
typedef __int64_t = ffi.Long;
typedef Dart__int64_t = int;
typedef __uint64_t = ffi.UnsignedLong;
typedef Dart__uint64_t = int;
typedef __int_least8_t = __int8_t;
typedef __uint_least8_t = __uint8_t;
typedef __int_least16_t = __int16_t;
typedef __uint_least16_t = __uint16_t;
typedef __int_least32_t = __int32_t;
typedef __uint_least32_t = __uint32_t;
typedef __int_least64_t = __int64_t;
typedef __uint_least64_t = __uint64_t;
typedef __quad_t = ffi.Long;
typedef Dart__quad_t = int;
typedef __u_quad_t = ffi.UnsignedLong;
typedef Dart__u_quad_t = int;
typedef __intmax_t = ffi.Long;
typedef Dart__intmax_t = int;
typedef __uintmax_t = ffi.UnsignedLong;
typedef Dart__uintmax_t = int;
typedef __dev_t = ffi.UnsignedLong;
typedef Dart__dev_t = int;
typedef __uid_t = ffi.UnsignedInt;
typedef Dart__uid_t = int;
typedef __gid_t = ffi.UnsignedInt;
typedef Dart__gid_t = int;
typedef __ino_t = ffi.UnsignedLong;
typedef Dart__ino_t = int;
typedef __ino64_t = ffi.UnsignedLong;
typedef Dart__ino64_t = int;
typedef __mode_t = ffi.UnsignedInt;
typedef Dart__mode_t = int;
typedef __nlink_t = ffi.UnsignedLong;
typedef Dart__nlink_t = int;
typedef __off_t = ffi.Long;
typedef Dart__off_t = int;
typedef __off64_t = ffi.Long;
typedef Dart__off64_t = int;
typedef __pid_t = ffi.Int;
typedef Dart__pid_t = int;

final class __fsid_t extends ffi.Struct {
  @ffi.Array.multi([2])
  external ffi.Array<ffi.Int> __val;
}

typedef __clock_t = ffi.Long;
typedef Dart__clock_t = int;
typedef __rlim_t = ffi.UnsignedLong;
typedef Dart__rlim_t = int;
typedef __rlim64_t = ffi.UnsignedLong;
typedef Dart__rlim64_t = int;
typedef __id_t = ffi.UnsignedInt;
typedef Dart__id_t = int;
typedef __time_t = ffi.Long;
typedef Dart__time_t = int;
typedef __useconds_t = ffi.UnsignedInt;
typedef Dart__useconds_t = int;
typedef __suseconds_t = ffi.Long;
typedef Dart__suseconds_t = int;
typedef __suseconds64_t = ffi.Long;
typedef Dart__suseconds64_t = int;
typedef __daddr_t = ffi.Int;
typedef Dart__daddr_t = int;
typedef __key_t = ffi.Int;
typedef Dart__key_t = int;
typedef __clockid_t = ffi.Int;
typedef Dart__clockid_t = int;
typedef __timer_t = ffi.Pointer<ffi.Void>;
typedef __blksize_t = ffi.Long;
typedef Dart__blksize_t = int;
typedef __blkcnt_t = ffi.Long;
typedef Dart__blkcnt_t = int;
typedef __blkcnt64_t = ffi.Long;
typedef Dart__blkcnt64_t = int;
typedef __fsblkcnt_t = ffi.UnsignedLong;
typedef Dart__fsblkcnt_t = int;
typedef __fsblkcnt64_t = ffi.UnsignedLong;
typedef Dart__fsblkcnt64_t = int;
typedef __fsfilcnt_t = ffi.UnsignedLong;
typedef Dart__fsfilcnt_t = int;
typedef __fsfilcnt64_t = ffi.UnsignedLong;
typedef Dart__fsfilcnt64_t = int;
typedef __fsword_t = ffi.Long;
typedef Dart__fsword_t = int;
typedef __ssize_t = ffi.Long;
typedef Dart__ssize_t = int;
typedef __syscall_slong_t = ffi.Long;
typedef Dart__syscall_slong_t = int;
typedef __syscall_ulong_t = ffi.UnsignedLong;
typedef Dart__syscall_ulong_t = int;
typedef __loff_t = __off64_t;
typedef __caddr_t = ffi.Pointer<ffi.Char>;
typedef __intptr_t = ffi.Long;
typedef Dart__intptr_t = int;
typedef __socklen_t = ffi.UnsignedInt;
typedef Dart__socklen_t = int;
typedef __sig_atomic_t = ffi.Int;
typedef Dart__sig_atomic_t = int;
typedef int_least8_t = __int_least8_t;
typedef int_least16_t = __int_least16_t;
typedef int_least32_t = __int_least32_t;
typedef int_least64_t = __int_least64_t;
typedef uint_least8_t = __uint_least8_t;
typedef uint_least16_t = __uint_least16_t;
typedef uint_least32_t = __uint_least32_t;
typedef uint_least64_t = __uint_least64_t;
typedef int_fast8_t = ffi.SignedChar;
typedef Dartint_fast8_t = int;
typedef int_fast16_t = ffi.Long;
typedef Dartint_fast16_t = int;
typedef int_fast32_t = ffi.Long;
typedef Dartint_fast32_t = int;
typedef int_fast64_t = ffi.Long;
typedef Dartint_fast64_t = int;
typedef uint_fast8_t = ffi.UnsignedChar;
typedef Dartuint_fast8_t = int;
typedef uint_fast16_t = ffi.UnsignedLong;
typedef Dartuint_fast16_t = int;
typedef uint_fast32_t = ffi.UnsignedLong;
typedef Dartuint_fast32_t = int;
typedef uint_fast64_t = ffi.UnsignedLong;
typedef Dartuint_fast64_t = int;
typedef intmax_t = __intmax_t;
typedef uintmax_t = __uintmax_t;

final class __locale_data extends ffi.Opaque {}

final class __locale_struct extends ffi.Struct {
  @ffi.Array.multi([13])
  external ffi.Array<ffi.Pointer<__locale_data>> __locales;

  external ffi.Pointer<ffi.UnsignedShort> __ctype_b;

  external ffi.Pointer<ffi.Int> __ctype_tolower;

  external ffi.Pointer<ffi.Int> __ctype_toupper;

  @ffi.Array.multi([13])
  external ffi.Array<ffi.Pointer<ffi.Char>> __names;
}

typedef __locale_t = ffi.Pointer<__locale_struct>;
typedef locale_t = __locale_t;
typedef byte_t = ffi.Char;
typedef Dartbyte_t = int;
typedef float32_t = ffi.Float;
typedef Dartfloat32_t = double;
typedef float64_t = ffi.Double;
typedef Dartfloat64_t = double;
typedef wasm_byte_t = byte_t;

final class wasm_byte_vec_t extends ffi.Struct {
  @ffi.Size()
  external int size;

  external ffi.Pointer<wasm_byte_t> data;
}

typedef wasm_name_t = wasm_byte_vec_t;

final class wasm_config_t extends ffi.Opaque {}

final class wasm_engine_t extends ffi.Opaque {}

final class wasm_store_t extends ffi.Opaque {}

/// ////////////////////////////////////////////////////////////////////////////
typedef wasm_mutability_t = ffi.Uint8;
typedef Dartwasm_mutability_t = int;

enum wasm_mutability_enum {
  WASM_CONST(0),
  WASM_VAR(1);

  final int value;
  const wasm_mutability_enum(this.value);

  static wasm_mutability_enum fromValue(int value) => switch (value) {
    0 => WASM_CONST,
    1 => WASM_VAR,
    _ => throw ArgumentError('Unknown value for wasm_mutability_enum: $value'),
  };
}

final class wasm_limits_t extends ffi.Struct {
  @ffi.Uint32()
  external int min;

  @ffi.Uint32()
  external int max;
}

final class wasm_valtype_t extends ffi.Opaque {}

final class wasm_valtype_vec_t extends ffi.Struct {
  @ffi.Size()
  external int size;

  external ffi.Pointer<ffi.Pointer<wasm_valtype_t>> data;
}

typedef wasm_valkind_t = ffi.Uint8;
typedef Dartwasm_valkind_t = int;

enum wasm_valkind_enum {
  WASM_I32(0),
  WASM_I64(1),
  WASM_F32(2),
  WASM_F64(3),
  WASM_EXTERNREF(128),
  WASM_FUNCREF(129);

  final int value;
  const wasm_valkind_enum(this.value);

  static wasm_valkind_enum fromValue(int value) => switch (value) {
    0 => WASM_I32,
    1 => WASM_I64,
    2 => WASM_F32,
    3 => WASM_F64,
    128 => WASM_EXTERNREF,
    129 => WASM_FUNCREF,
    _ => throw ArgumentError('Unknown value for wasm_valkind_enum: $value'),
  };
}

final class wasm_functype_t extends ffi.Opaque {}

final class wasm_functype_vec_t extends ffi.Struct {
  @ffi.Size()
  external int size;

  external ffi.Pointer<ffi.Pointer<wasm_functype_t>> data;
}

final class wasm_globaltype_t extends ffi.Opaque {}

final class wasm_globaltype_vec_t extends ffi.Struct {
  @ffi.Size()
  external int size;

  external ffi.Pointer<ffi.Pointer<wasm_globaltype_t>> data;
}

final class wasm_tabletype_t extends ffi.Opaque {}

final class wasm_tabletype_vec_t extends ffi.Struct {
  @ffi.Size()
  external int size;

  external ffi.Pointer<ffi.Pointer<wasm_tabletype_t>> data;
}

final class wasm_memorytype_t extends ffi.Opaque {}

final class wasm_memorytype_vec_t extends ffi.Struct {
  @ffi.Size()
  external int size;

  external ffi.Pointer<ffi.Pointer<wasm_memorytype_t>> data;
}

final class wasm_externtype_t extends ffi.Opaque {}

final class wasm_externtype_vec_t extends ffi.Struct {
  @ffi.Size()
  external int size;

  external ffi.Pointer<ffi.Pointer<wasm_externtype_t>> data;
}

typedef wasm_externkind_t = ffi.Uint8;
typedef Dartwasm_externkind_t = int;

enum wasm_externkind_enum {
  WASM_EXTERN_FUNC(0),
  WASM_EXTERN_GLOBAL(1),
  WASM_EXTERN_TABLE(2),
  WASM_EXTERN_MEMORY(3);

  final int value;
  const wasm_externkind_enum(this.value);

  static wasm_externkind_enum fromValue(int value) => switch (value) {
    0 => WASM_EXTERN_FUNC,
    1 => WASM_EXTERN_GLOBAL,
    2 => WASM_EXTERN_TABLE,
    3 => WASM_EXTERN_MEMORY,
    _ => throw ArgumentError('Unknown value for wasm_externkind_enum: $value'),
  };
}

final class wasm_importtype_t extends ffi.Opaque {}

final class wasm_importtype_vec_t extends ffi.Struct {
  @ffi.Size()
  external int size;

  external ffi.Pointer<ffi.Pointer<wasm_importtype_t>> data;
}

final class wasm_exporttype_t extends ffi.Opaque {}

final class wasm_exporttype_vec_t extends ffi.Struct {
  @ffi.Size()
  external int size;

  external ffi.Pointer<ffi.Pointer<wasm_exporttype_t>> data;
}

/// ////////////////////////////////////////////////////////////////////////////
final class wasm_ref_t extends ffi.Opaque {}

final class UnnamedUnion extends ffi.Union {
  @ffi.Int32()
  external int i32;

  @ffi.Int64()
  external int i64;

  @float32_t()
  external double f32;

  @float64_t()
  external double f64;

  external ffi.Pointer<wasm_ref_t> ref;
}

final class wasm_val_t extends ffi.Struct {
  @wasm_valkind_t()
  external int kind;

  external UnnamedUnion of;
}

final class wasm_val_vec_t extends ffi.Struct {
  @ffi.Size()
  external int size;

  external ffi.Pointer<wasm_val_t> data;
}

final class wasm_frame_t extends ffi.Opaque {}

final class wasm_frame_vec_t extends ffi.Struct {
  @ffi.Size()
  external int size;

  external ffi.Pointer<ffi.Pointer<wasm_frame_t>> data;
}

final class wasm_instance_t extends ffi.Opaque {}

typedef wasm_message_t = wasm_name_t;

final class wasm_trap_t extends ffi.Opaque {}

final class wasm_foreign_t extends ffi.Opaque {}

final class wasm_module_t extends ffi.Opaque {}

final class wasm_shared_module_t extends ffi.Opaque {}

final class wasm_func_t extends ffi.Opaque {}

typedef wasm_func_callback_tFunction =
    ffi.Pointer<wasm_trap_t> Function(
      ffi.Pointer<wasm_val_vec_t> args,
      ffi.Pointer<wasm_val_vec_t> results,
    );
typedef wasm_func_callback_t =
    ffi.Pointer<ffi.NativeFunction<wasm_func_callback_tFunction>>;
typedef wasm_func_callback_with_env_tFunction =
    ffi.Pointer<wasm_trap_t> Function(
      ffi.Pointer<ffi.Void> env,
      ffi.Pointer<wasm_val_vec_t> args,
      ffi.Pointer<wasm_val_vec_t> results,
    );
typedef wasm_func_callback_with_env_t =
    ffi.Pointer<ffi.NativeFunction<wasm_func_callback_with_env_tFunction>>;

final class wasm_global_t extends ffi.Opaque {}

final class wasm_table_t extends ffi.Opaque {}

typedef wasm_table_size_t = ffi.Uint32;
typedef Dartwasm_table_size_t = int;

final class wasm_memory_t extends ffi.Opaque {}

typedef wasm_memory_pages_t = ffi.Uint32;
typedef Dartwasm_memory_pages_t = int;

final class wasm_extern_t extends ffi.Opaque {}

final class wasm_extern_vec_t extends ffi.Struct {
  @ffi.Size()
  external int size;

  external ffi.Pointer<ffi.Pointer<wasm_extern_t>> data;
}

final class wasi_config_t extends ffi.Opaque {}

/// \brief The permissions granted for a directory when preopening it.
enum wasi_dir_perms_flags {
  /// \brief This directory can be read, for example its entries can be iterated
  WASMTIME_WASI_DIR_PERMS_READ(1),

  /// \brief This directory can be written to, for example new files can be
  /// created within it.
  WASMTIME_WASI_DIR_PERMS_WRITE(2);

  final int value;
  const wasi_dir_perms_flags(this.value);

  static wasi_dir_perms_flags fromValue(int value) => switch (value) {
    1 => WASMTIME_WASI_DIR_PERMS_READ,
    2 => WASMTIME_WASI_DIR_PERMS_WRITE,
    _ => throw ArgumentError('Unknown value for wasi_dir_perms_flags: $value'),
  };
}

/// \brief The permissions granted for directories when preopening them,
/// which is a bitmask with flag values from wasi_dir_perms_flags.
typedef wasi_dir_perms = ffi.Size;
typedef Dartwasi_dir_perms = int;

/// \brief The permissions granted for files when preopening a directory.
enum wasi_file_perms_flags {
  /// \brief Files can be read.
  WASMTIME_WASI_FILE_PERMS_READ(1),

  /// \brief Files can be written to.
  WASMTIME_WASI_FILE_PERMS_WRITE(2);

  final int value;
  const wasi_file_perms_flags(this.value);

  static wasi_file_perms_flags fromValue(int value) => switch (value) {
    1 => WASMTIME_WASI_FILE_PERMS_READ,
    2 => WASMTIME_WASI_FILE_PERMS_WRITE,
    _ => throw ArgumentError('Unknown value for wasi_file_perms_flags: $value'),
  };
}

/// \brief The max permissions granted a file within a preopened directory,
/// which is a bitmask with flag values from wasi_file_perms_flags.
typedef wasi_file_perms = ffi.Size;
typedef Dartwasi_file_perms = int;

final class wasmtime_error extends ffi.Opaque {}

/// \typedef wasmtime_error_t
/// \brief Convenience alias for #wasmtime_error
///
/// \struct wasmtime_error
/// \brief Errors generated by Wasmtime.
/// \headerfile wasmtime/error.h
///
/// This opaque type represents an error that happened as part of one of the
/// functions below. Errors primarily have an error message associated with them
/// at this time, which you can acquire by calling #wasmtime_error_message.
///
/// Errors are safe to share across threads and must be deleted with
/// #wasmtime_error_delete.
typedef wasmtime_error_t = wasmtime_error;

/// \brief Specifier for how Wasmtime will compile code, values are in
/// #wasmtime_strategy_enum
typedef wasmtime_strategy_t = ffi.Uint8;
typedef Dartwasmtime_strategy_t = int;

/// \brief Different ways that Wasmtime can compile WebAssembly
///
/// The default value is #WASMTIME_STRATEGY_AUTO.
enum wasmtime_strategy_enum {
  /// Automatically picks the compilation backend, currently always defaulting
  /// to Cranelift.
  WASMTIME_STRATEGY_AUTO(0),

  /// Indicates that Wasmtime will unconditionally use Cranelift to compile
  /// WebAssembly code.
  WASMTIME_STRATEGY_CRANELIFT(1);

  final int value;
  const wasmtime_strategy_enum(this.value);

  static wasmtime_strategy_enum fromValue(int value) => switch (value) {
    0 => WASMTIME_STRATEGY_AUTO,
    1 => WASMTIME_STRATEGY_CRANELIFT,
    _ => throw ArgumentError(
      'Unknown value for wasmtime_strategy_enum: $value',
    ),
  };
}

/// \brief Specifier of what optimization level to use for generated JIT code.
///
/// See #wasmtime_opt_level_enum for possible values.
typedef wasmtime_opt_level_t = ffi.Uint8;
typedef Dartwasmtime_opt_level_t = int;

/// \brief Different ways Wasmtime can optimize generated code.
///
/// The default value is #WASMTIME_OPT_LEVEL_SPEED.
enum wasmtime_opt_level_enum {
  /// Generated code will not be optimized at all.
  WASMTIME_OPT_LEVEL_NONE(0),

  /// Generated code will be optimized purely for speed.
  WASMTIME_OPT_LEVEL_SPEED(1),

  /// Generated code will be optimized, but some speed optimizations are
  /// disabled if they cause the generated code to be significantly larger.
  WASMTIME_OPT_LEVEL_SPEED_AND_SIZE(2);

  final int value;
  const wasmtime_opt_level_enum(this.value);

  static wasmtime_opt_level_enum fromValue(int value) => switch (value) {
    0 => WASMTIME_OPT_LEVEL_NONE,
    1 => WASMTIME_OPT_LEVEL_SPEED,
    2 => WASMTIME_OPT_LEVEL_SPEED_AND_SIZE,
    _ => throw ArgumentError(
      'Unknown value for wasmtime_opt_level_enum: $value',
    ),
  };
}

/// \brief Different ways wasmtime can enable profiling JIT code.
///
/// See #wasmtime_profiling_strategy_enum for possible values.
typedef wasmtime_profiling_strategy_t = ffi.Uint8;
typedef Dartwasmtime_profiling_strategy_t = int;

/// \brief Different ways to profile JIT code.
///
/// The default is #WASMTIME_PROFILING_STRATEGY_NONE.
enum wasmtime_profiling_strategy_enum {
  /// No profiling is enabled at runtime.
  WASMTIME_PROFILING_STRATEGY_NONE(0),

  /// Linux's "jitdump" support in `perf` is enabled and when Wasmtime is run
  /// under `perf` necessary calls will be made to profile generated JIT code.
  WASMTIME_PROFILING_STRATEGY_JITDUMP(1),

  /// Support for VTune will be enabled and the VTune runtime will be informed,
  /// at runtime, about JIT code.
  ///
  /// Note that this isn't always enabled at build time.
  WASMTIME_PROFILING_STRATEGY_VTUNE(2),

  /// Linux's simple "perfmap" support in `perf` is enabled and when Wasmtime is
  /// run under `perf` necessary calls will be made to profile generated JIT
  /// code.
  WASMTIME_PROFILING_STRATEGY_PERFMAP(3);

  final int value;
  const wasmtime_profiling_strategy_enum(this.value);

  static wasmtime_profiling_strategy_enum fromValue(int value) =>
      switch (value) {
        0 => WASMTIME_PROFILING_STRATEGY_NONE,
        1 => WASMTIME_PROFILING_STRATEGY_JITDUMP,
        2 => WASMTIME_PROFILING_STRATEGY_VTUNE,
        3 => WASMTIME_PROFILING_STRATEGY_PERFMAP,
        _ => throw ArgumentError(
          'Unknown value for wasmtime_profiling_strategy_enum: $value',
        ),
      };
}

typedef wasmtime_memory_get_callback_tFunction =
    ffi.Pointer<ffi.Uint8> Function(
      ffi.Pointer<ffi.Void> env,
      ffi.Pointer<ffi.Size> byte_size,
      ffi.Pointer<ffi.Size> byte_capacity,
    );

/// Return the data from a LinearMemory instance.
///
/// The size in bytes as well as the maximum number of bytes that can be
/// allocated should be returned as well.
///
/// For more information about see the Rust documentation at
/// https://docs.wasmtime.dev/api/wasmtime/trait.LinearMemory.html
typedef wasmtime_memory_get_callback_t =
    ffi.Pointer<ffi.NativeFunction<wasmtime_memory_get_callback_tFunction>>;
typedef wasmtime_memory_grow_callback_tFunction =
    ffi.Pointer<wasmtime_error_t> Function(
      ffi.Pointer<ffi.Void> env,
      ffi.Size new_size,
    );
typedef Dartwasmtime_memory_grow_callback_tFunction =
    ffi.Pointer<wasmtime_error_t> Function(
      ffi.Pointer<ffi.Void> env,
      int new_size,
    );

/// Grow the memory to the `new_size` in bytes.
///
/// For more information about the parameters see the Rust documentation at
/// https://docs.wasmtime.dev/api/wasmtime/trait.LinearMemory.html#tymethod.grow_to
typedef wasmtime_memory_grow_callback_t =
    ffi.Pointer<ffi.NativeFunction<wasmtime_memory_grow_callback_tFunction>>;

/// A LinearMemory instance created from a #wasmtime_new_memory_callback_t.
///
/// For more information see the Rust documentation at
/// https://docs.wasmtime.dev/api/wasmtime/trait.LinearMemory.html
final class wasmtime_linear_memory extends ffi.Struct {
  /// User provided value to be passed to get_memory and grow_memory
  external ffi.Pointer<ffi.Void> env;

  /// Callback to get the memory and size of this LinearMemory
  external wasmtime_memory_get_callback_t get_memory;

  /// Callback to request growing the memory
  external wasmtime_memory_grow_callback_t grow_memory;

  /// An optional finalizer for env
  external ffi.Pointer<
    ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>
  >
  finalizer;
}

typedef wasmtime_linear_memory_t = wasmtime_linear_memory;
typedef wasmtime_new_memory_callback_tFunction =
    ffi.Pointer<wasmtime_error_t> Function(
      ffi.Pointer<ffi.Void> env,
      ffi.Pointer<wasm_memorytype_t> ty,
      ffi.Size minimum,
      ffi.Size maximum,
      ffi.Size reserved_size_in_bytes,
      ffi.Size guard_size_in_bytes,
      ffi.Pointer<wasmtime_linear_memory_t> memory_ret,
    );
typedef Dartwasmtime_new_memory_callback_tFunction =
    ffi.Pointer<wasmtime_error_t> Function(
      ffi.Pointer<ffi.Void> env,
      ffi.Pointer<wasm_memorytype_t> ty,
      int minimum,
      int maximum,
      int reserved_size_in_bytes,
      int guard_size_in_bytes,
      ffi.Pointer<wasmtime_linear_memory_t> memory_ret,
    );

/// A callback to create a new LinearMemory from the specified parameters.
///
/// The result should be written to `memory_ret` and wasmtime will own the values
/// written into that struct.
///
/// This callback must be thread-safe.
///
/// For more information about the parameters see the Rust documentation at
/// https://docs.wasmtime.dev/api/wasmtime/trait.MemoryCreator.html#tymethod.new_memory
typedef wasmtime_new_memory_callback_t =
    ffi.Pointer<ffi.NativeFunction<wasmtime_new_memory_callback_tFunction>>;

/// A representation of custom memory creator and methods for an instance of
/// LinearMemory.
///
/// For more information see the Rust documentation at
/// https://docs.wasmtime.dev/api/wasmtime/trait.MemoryCreator.html
final class wasmtime_memory_creator extends ffi.Struct {
  /// User provided value to be passed to new_memory
  external ffi.Pointer<ffi.Void> env;

  /// The callback to create new memory, must be thread safe
  external wasmtime_new_memory_callback_t new_memory;

  /// An optional finalizer for env.
  external ffi.Pointer<
    ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>
  >
  finalizer;
}

typedef wasmtime_memory_creator_t = wasmtime_memory_creator;

final class wasmtime_pooling_allocation_config_t extends ffi.Opaque {}

final class wasmtime_module extends ffi.Opaque {}

/// \typedef wasmtime_module_t
/// \brief Convenience alias for #wasmtime_module
///
/// \struct wasmtime_module
/// \brief A compiled Wasmtime module.
///
/// This type represents a compiled WebAssembly module. The compiled module is
/// ready to be instantiated and can be inspected for imports/exports. It is safe
/// to use a module across multiple threads simultaneously.
typedef wasmtime_module_t = wasmtime_module;

final class wasmtime_sharedmemory extends ffi.Opaque {}

/// \brief Interface for shared memories.
///
/// For more information see the Rust documentation at:
/// https://docs.wasmtime.dev/api/wasmtime/struct.SharedMemory.html
typedef wasmtime_sharedmemory_t = wasmtime_sharedmemory;

final class wasmtime_wasip2_config_t extends ffi.Opaque {}

final class wasmtime_store extends ffi.Opaque {}

/// \typedef wasmtime_store_t
/// \brief Convenience alias for #wasmtime_store_t
///
/// \struct wasmtime_store
/// \brief Storage of WebAssembly objects
///
/// A store is the unit of isolation between WebAssembly instances in an
/// embedding of Wasmtime. Values in one #wasmtime_store_t cannot flow into
/// another #wasmtime_store_t. Stores are cheap to create and cheap to dispose.
/// It's expected that one-off stores are common in embeddings.
///
/// Objects stored within a #wasmtime_store_t are referenced with integer handles
/// rather than interior pointers. This means that most APIs require that the
/// store be explicitly passed in, which is done via #wasmtime_context_t. It is
/// safe to move a #wasmtime_store_t to any thread at any time. A store generally
/// cannot be concurrently used, however.
typedef wasmtime_store_t = wasmtime_store;

final class wasmtime_context extends ffi.Opaque {}

/// \typedef wasmtime_context_t
/// \brief Convenience alias for #wasmtime_context
///
/// \struct wasmtime_context
/// \brief An interior pointer into a #wasmtime_store_t which is used as
/// "context" for many functions.
///
/// This context pointer is used pervasively throughout Wasmtime's API. This can
/// be acquired from #wasmtime_store_context or #wasmtime_caller_context. The
/// context pointer for a store is the same for the entire lifetime of a store,
/// so it can safely be stored adjacent to a #wasmtime_store_t itself.
///
/// Usage of a #wasmtime_context_t must not outlive the original
/// #wasmtime_store_t. Additionally #wasmtime_context_t can only be used in
/// situations where it has explicitly been granted access to doing so. For
/// example finalizers cannot use #wasmtime_context_t because they are not given
/// access to it.
typedef wasmtime_context_t = wasmtime_context;

/// \brief An enum for the behavior before extending the epoch deadline.
typedef wasmtime_update_deadline_kind_t = ffi.Uint8;
typedef Dartwasmtime_update_deadline_kind_t = int;

/// \brief Representation of a function in Wasmtime.
///
/// Functions in Wasmtime are represented as an index into a store and don't
/// have any data or destructor associated with the #wasmtime_func_t value.
/// Functions cannot interoperate between #wasmtime_store_t instances and if the
/// wrong function is passed to the wrong store then it may trigger an assertion
/// to abort the process.
final class wasmtime_func extends ffi.Struct {
  /// Internal identifier of what store this belongs to.
  ///
  /// This field may be zero when used in conjunction with #wasmtime_val_t
  /// to represent a null `funcref` value in WebAssembly. For a valid function
  /// this field is otherwise never zero.
  @ffi.Uint64()
  external int store_id;

  /// Private field for Wasmtime, undefined if `store_id` is zero.
  external ffi.Pointer<ffi.Void> __private;
}

typedef wasmtime_func_t = wasmtime_func;

final class UnnamedStruct extends ffi.Struct {
  /// Internal identifier of what store this belongs to, never zero.
  @ffi.Uint64()
  external int store_id;

  /// Private field for Wasmtime.
  @ffi.Uint32()
  external int __private1;
}

/// \brief Representation of a table in Wasmtime.
///
/// Tables in Wasmtime are represented as an index into a store and don't
/// have any data or destructor associated with the #wasmtime_table_t value.
/// Tables cannot interoperate between #wasmtime_store_t instances and if the
/// wrong table is passed to the wrong store then it may trigger an assertion
/// to abort the process.
final class wasmtime_table extends ffi.Struct {
  external UnnamedStruct unnamed;

  /// Private field for Wasmtime.
  @ffi.Uint32()
  external int __private2;
}

typedef wasmtime_table_t = wasmtime_table;

final class UnnamedStruct$1 extends ffi.Struct {
  /// Internal identifier of what store this belongs to, never zero.
  @ffi.Uint64()
  external int store_id;

  /// Private field for Wasmtime.
  @ffi.Uint32()
  external int __private1;
}

/// \brief Representation of a memory in Wasmtime.
///
/// Memories in Wasmtime are represented as an index into a store and don't
/// have any data or destructor associated with the #wasmtime_memory_t value.
/// Memories cannot interoperate between #wasmtime_store_t instances and if the
/// wrong memory is passed to the wrong store then it may trigger an assertion
/// to abort the process.
final class wasmtime_memory extends ffi.Struct {
  external UnnamedStruct$1 unnamed;

  /// Private field for Wasmtime.
  @ffi.Uint32()
  external int __private2;
}

typedef wasmtime_memory_t = wasmtime_memory;

/// \brief Representation of a global in Wasmtime.
///
/// Globals in Wasmtime are represented as an index into a store and don't
/// have any data or destructor associated with the #wasmtime_global_t value.
/// Globals cannot interoperate between #wasmtime_store_t instances and if the
/// wrong global is passed to the wrong store then it may trigger an assertion
/// to abort the process.
final class wasmtime_global extends ffi.Struct {
  /// Internal identifier of what store this belongs to, never zero.
  @ffi.Uint64()
  external int store_id;

  /// Private field for Wasmtime.
  @ffi.Uint32()
  external int __private1;

  /// Private field for Wasmtime.
  @ffi.Uint32()
  external int __private2;

  /// Private field for Wasmtime.
  @ffi.Uint32()
  external int __private3;
}

typedef wasmtime_global_t = wasmtime_global;

/// \brief Discriminant of #wasmtime_extern_t
typedef wasmtime_extern_kind_t = ffi.Uint8;
typedef Dartwasmtime_extern_kind_t = int;

/// \typedef wasmtime_extern_union_t
/// \brief Convenience alias for #wasmtime_extern_union
///
/// \union wasmtime_extern_union
/// \brief Container for different kinds of extern items.
///
/// This type is contained in #wasmtime_extern_t and contains the payload for the
/// various kinds of items an extern wasm item can be.
final class wasmtime_extern_union extends ffi.Union {
  /// Field used if #wasmtime_extern_t::kind is #WASMTIME_EXTERN_FUNC
  external wasmtime_func_t func;

  /// Field used if #wasmtime_extern_t::kind is #WASMTIME_EXTERN_GLOBAL
  external wasmtime_global_t global;

  /// Field used if #wasmtime_extern_t::kind is #WASMTIME_EXTERN_TABLE
  external wasmtime_table_t table;

  /// Field used if #wasmtime_extern_t::kind is #WASMTIME_EXTERN_MEMORY
  external wasmtime_memory_t memory;

  /// Field used if #wasmtime_extern_t::kind is #WASMTIME_EXTERN_SHAREDMEMORY
  external ffi.Pointer<wasmtime_sharedmemory> sharedmemory;
}

typedef wasmtime_extern_union_t = wasmtime_extern_union;

/// \typedef wasmtime_extern_t
/// \brief Convenience alias for #wasmtime_extern_t
///
/// \union wasmtime_extern
/// \brief Container for different kinds of extern items.
///
/// Note that this structure may contain an owned value, namely
/// #wasmtime_module_t, depending on the context in which this is used. APIs
/// which consume a #wasmtime_extern_t do not take ownership, but APIs that
/// return #wasmtime_extern_t require that #wasmtime_extern_delete is called to
/// deallocate the value.
final class wasmtime_extern extends ffi.Struct {
  /// Discriminant of which field of #of is valid.
  @wasmtime_extern_kind_t()
  external int kind;

  /// Container for the extern item's value.
  external wasmtime_extern_union_t of;
}

typedef wasmtime_extern_t = wasmtime_extern;

/// \typedef wasmtime_anyref_t
/// \brief Convenience alias for #wasmtime_anyref
///
/// \struct wasmtime_anyref
/// \brief A WebAssembly value in the `any` hierarchy of GC types.
///
/// This structure represents an `anyref` that WebAssembly can create and
/// pass back to the host. The host can also create values to pass to a guest.
///
/// Note that this structure does not itself contain the data that it refers to.
/// Instead to contains metadata to point back within a #wasmtime_context_t, so
/// referencing the internal data requires using a `wasmtime_context_t`.
///
/// Anyref values are required to be explicitly unrooted via
/// #wasmtime_anyref_unroot to enable them to be garbage-collected.
///
/// If you do not unroot the value, *even if you free the corresponding
/// Store*, there will be some memory leaked, because GC roots use a
/// separate allocation to track liveness.
///
/// Null anyref values are represented by this structure and can be tested and
/// created with the `wasmtime_anyref_is_null` and `wasmtime_anyref_set_null`
/// functions.
final class wasmtime_anyref extends ffi.Struct {
  /// Internal metadata tracking within the store, embedders should not
  /// configure or modify these fields.
  @ffi.Uint64()
  external int store_id;

  /// Internal to Wasmtime.
  @ffi.Uint32()
  external int __private1;

  /// Internal to Wasmtime.
  @ffi.Uint32()
  external int __private2;

  /// Internal to Wasmtime.
  external ffi.Pointer<ffi.Void> __private3;
}

typedef wasmtime_anyref_t = wasmtime_anyref;

/// \typedef wasmtime_externref_t
/// \brief Convenience alias for #wasmtime_externref
///
/// \struct wasmtime_externref
/// \brief A host-defined un-forgeable reference to pass into WebAssembly.
///
/// This structure represents an `externref` that can be passed to WebAssembly.
/// It cannot be forged by WebAssembly itself and is guaranteed to have been
/// created by the host.
///
/// This structure is similar to #wasmtime_anyref_t but represents the
/// `externref` type in WebAssembly. This can be created on the host from
/// arbitrary host pointers/destructors. Note that this value is itself a
/// reference into a #wasmtime_context_t and must be explicitly unrooted to
/// enable garbage collection.
///
/// Note that null is represented with this structure and created with
/// `wasmtime_externref_set_null`. Null can be tested for with the
/// `wasmtime_externref_is_null` function.
final class wasmtime_externref extends ffi.Struct {
  /// Internal metadata tracking within the store, embedders should not
  /// configure or modify these fields.
  @ffi.Uint64()
  external int store_id;

  /// Internal to Wasmtime.
  @ffi.Uint32()
  external int __private1;

  /// Internal to Wasmtime.
  @ffi.Uint32()
  external int __private2;

  /// Internal to Wasmtime.
  external ffi.Pointer<ffi.Void> __private3;
}

typedef wasmtime_externref_t = wasmtime_externref;

/// \brief Discriminant stored in #wasmtime_val::kind
typedef wasmtime_valkind_t = ffi.Uint8;
typedef Dartwasmtime_valkind_t = int;

/// \typedef wasmtime_valunion_t
/// \brief Convenience alias for #wasmtime_valunion
///
/// \union wasmtime_valunion
/// \brief Container for different kinds of wasm values.
///
/// This type is contained in #wasmtime_val_t and contains the payload for the
/// various kinds of items a value can be.
final class wasmtime_valunion extends ffi.Union {
  /// Field used if #wasmtime_val_t::kind is #WASMTIME_I32
  @ffi.Int32()
  external int i32;

  /// Field used if #wasmtime_val_t::kind is #WASMTIME_I64
  @ffi.Int64()
  external int i64;

  /// Field used if #wasmtime_val_t::kind is #WASMTIME_F32
  @float32_t()
  external double f32;

  /// Field used if #wasmtime_val_t::kind is #WASMTIME_F64
  @float64_t()
  external double f64;

  /// Field used if #wasmtime_val_t::kind is #WASMTIME_ANYREF
  external wasmtime_anyref_t anyref;

  /// Field used if #wasmtime_val_t::kind is #WASMTIME_EXTERNREF
  external wasmtime_externref_t externref;

  /// Field used if #wasmtime_val_t::kind is #WASMTIME_FUNCREF
  ///
  /// Use `wasmtime_funcref_is_null` to test whether this is a null function
  /// reference.
  external wasmtime_func_t funcref;

  /// Field used if #wasmtime_val_t::kind is #WASMTIME_V128
  @ffi.Array.multi([16])
  external ffi.Array<ffi.Uint8> v128;
}

typedef wasmtime_valunion_t = wasmtime_valunion;

/// \typedef wasmtime_val_raw_t
/// \brief Convenience alias for #wasmtime_val_raw
///
/// \union wasmtime_val_raw
/// \brief Container for possible wasm values.
///
/// This type is used on conjunction with #wasmtime_func_new_unchecked as well
/// as #wasmtime_func_call_unchecked. Instances of this type do not have type
/// information associated with them, it's up to the embedder to figure out
/// how to interpret the bits contained within, often using some other channel
/// to determine the type.
final class wasmtime_val_raw extends ffi.Union {
  /// Field for when this val is a WebAssembly `i32` value.
  ///
  /// Note that this field is always stored in a little-endian format.
  @ffi.Int32()
  external int i32;

  /// Field for when this val is a WebAssembly `i64` value.
  ///
  /// Note that this field is always stored in a little-endian format.
  @ffi.Int64()
  external int i64;

  /// Field for when this val is a WebAssembly `f32` value.
  ///
  /// Note that this field is always stored in a little-endian format.
  @float32_t()
  external double f32;

  /// Field for when this val is a WebAssembly `f64` value.
  ///
  /// Note that this field is always stored in a little-endian format.
  @float64_t()
  external double f64;

  /// Field for when this val is a WebAssembly `v128` value.
  ///
  /// Note that this field is always stored in a little-endian format.
  @ffi.Array.multi([16])
  external ffi.Array<ffi.Uint8> v128;

  /// Field for when this val is a WebAssembly `anyref` value.
  ///
  /// If this is set to 0 then it's a null anyref, otherwise this must be
  /// passed to `wasmtime_anyref_from_raw` to determine the
  /// `wasmtime_anyref_t`.
  ///
  /// Note that this field is always stored in a little-endian format.
  @ffi.Uint32()
  external int anyref;

  /// Field for when this val is a WebAssembly `externref` value.
  ///
  /// If this is set to 0 then it's a null externref, otherwise this must be
  /// passed to `wasmtime_externref_from_raw` to determine the
  /// `wasmtime_externref_t`.
  ///
  /// Note that this field is always stored in a little-endian format.
  @ffi.Uint32()
  external int externref;

  /// Field for when this val is a WebAssembly `funcref` value.
  ///
  /// If this is set to 0 then it's a null funcref, otherwise this must be
  /// passed to `wasmtime_func_from_raw` to determine the `wasmtime_func_t`.
  ///
  /// Note that this field is always stored in a little-endian format.
  external ffi.Pointer<ffi.Void> funcref;
}

typedef wasmtime_val_raw_t = wasmtime_val_raw;

/// \typedef wasmtime_val_t
/// \brief Convenience alias for #wasmtime_val_t
///
/// \union wasmtime_val
/// \brief Container for different kinds of wasm values.
///
/// Note that this structure may contain an owned value, namely rooted GC
/// references, depending on the context in which this is used. APIs which
/// consume a #wasmtime_val_t do not take ownership, but APIs that return
/// #wasmtime_val_t require that #wasmtime_val_unroot is called to clean up
/// any possible GC roots in the value.
///
/// If you do not unroot the value, *even if you free the corresponding
/// Store*, there will be some memory leaked, because GC roots use a
/// separate allocation to track liveness.
final class wasmtime_val extends ffi.Struct {
  /// Discriminant of which field of #of is valid.
  @wasmtime_valkind_t()
  external int kind;

  /// Container for the extern item's value.
  external wasmtime_valunion_t of;
}

typedef wasmtime_val_t = wasmtime_val;

final class wasmtime_caller extends ffi.Opaque {}

/// \typedef wasmtime_caller_t
/// \brief Alias to #wasmtime_caller
///
/// \brief Structure used to learn about the caller of a host-defined function.
/// \struct wasmtime_caller
///
/// This structure is an argument to #wasmtime_func_callback_t. The purpose
/// of this structure is acquire a #wasmtime_context_t pointer to interact with
/// objects, but it can also be used for inspect the state of the caller (such as
/// getting memories and functions) with #wasmtime_caller_export_get.
///
/// This object is never owned and does not need to be deleted.
typedef wasmtime_caller_t = wasmtime_caller;
typedef wasmtime_func_callback_tFunction =
    ffi.Pointer<wasm_trap_t> Function(
      ffi.Pointer<ffi.Void> env,
      ffi.Pointer<wasmtime_caller_t> caller,
      ffi.Pointer<wasmtime_val_t> args,
      ffi.Size nargs,
      ffi.Pointer<wasmtime_val_t> results,
      ffi.Size nresults,
    );
typedef Dartwasmtime_func_callback_tFunction =
    ffi.Pointer<wasm_trap_t> Function(
      ffi.Pointer<ffi.Void> env,
      ffi.Pointer<wasmtime_caller_t> caller,
      ffi.Pointer<wasmtime_val_t> args,
      int nargs,
      ffi.Pointer<wasmtime_val_t> results,
      int nresults,
    );

/// \brief Callback signature for #wasmtime_func_new.
///
/// This is the function signature for host functions that can be made accessible
/// to WebAssembly. The arguments to this function are:
///
/// \param env user-provided argument passed to #wasmtime_func_new
/// \param caller a temporary object that can only be used during this function
/// call. Used to acquire #wasmtime_context_t or caller's state
/// \param args the arguments provided to this function invocation
/// \param nargs how many arguments are provided
/// \param results where to write the results of this function
/// \param nresults how many results must be produced
///
/// Callbacks are guaranteed to get called with the right types of arguments, but
/// they must produce the correct number and types of results. Failure to do so
/// will cause traps to get raised on the wasm side.
///
/// This callback can optionally return a #wasm_trap_t indicating that a trap
/// should be raised in WebAssembly. It's expected that in this case the caller
/// relinquishes ownership of the trap and it is passed back to the engine.
typedef wasmtime_func_callback_t =
    ffi.Pointer<ffi.NativeFunction<wasmtime_func_callback_tFunction>>;
typedef wasmtime_func_unchecked_callback_tFunction =
    ffi.Pointer<wasm_trap_t> Function(
      ffi.Pointer<ffi.Void> env,
      ffi.Pointer<wasmtime_caller_t> caller,
      ffi.Pointer<wasmtime_val_raw_t> args_and_results,
      ffi.Size num_args_and_results,
    );
typedef Dartwasmtime_func_unchecked_callback_tFunction =
    ffi.Pointer<wasm_trap_t> Function(
      ffi.Pointer<ffi.Void> env,
      ffi.Pointer<wasmtime_caller_t> caller,
      ffi.Pointer<wasmtime_val_raw_t> args_and_results,
      int num_args_and_results,
    );

/// \brief Callback signature for #wasmtime_func_new_unchecked.
///
/// This is the function signature for host functions that can be made accessible
/// to WebAssembly. The arguments to this function are:
///
/// \param env user-provided argument passed to #wasmtime_func_new_unchecked
/// \param caller a temporary object that can only be used during this function
/// call. Used to acquire #wasmtime_context_t or caller's state
/// \param args_and_results storage space for both the parameters to the
/// function as well as the results of the function. The size of this
/// array depends on the function type that the host function is created
/// with, but it will be the maximum of the number of parameters and
/// number of results.
/// \param num_args_and_results the size of the `args_and_results` parameter in
/// units of #wasmtime_val_raw_t.
///
/// This callback can optionally return a #wasm_trap_t indicating that a trap
/// should be raised in WebAssembly. It's expected that in this case the caller
/// relinquishes ownership of the trap and it is passed back to the engine.
///
/// This differs from #wasmtime_func_callback_t in that the payload of
/// `args_and_results` does not have type information, nor does it have sizing
/// information. This is especially unsafe because it's only valid within the
/// particular #wasm_functype_t that the function was created with. The onus is
/// on the embedder to ensure that `args_and_results` are all read correctly
/// for parameters and all written for results within the execution of a
/// function.
///
/// Parameters will be listed starting at index 0 in the `args_and_results`
/// array. Results are also written starting at index 0, which will overwrite
/// the arguments.
typedef wasmtime_func_unchecked_callback_t =
    ffi.Pointer<ffi.NativeFunction<wasmtime_func_unchecked_callback_tFunction>>;

/// \brief Representation of a instance in Wasmtime.
///
/// Instances are represented with a 64-bit identifying integer in Wasmtime.
/// They do not have any destructor associated with them. Instances cannot
/// interoperate between #wasmtime_store_t instances and if the wrong instance
/// is passed to the wrong store then it may trigger an assertion to abort the
/// process.
final class wasmtime_instance extends ffi.Struct {
  /// Internal identifier of what store this belongs to, never zero.
  @ffi.Uint64()
  external int store_id;

  /// Private data for use in Wasmtime.
  @ffi.Size()
  external int __private;
}

typedef wasmtime_instance_t = wasmtime_instance;

final class wasmtime_instance_pre extends ffi.Opaque {}

/// \brief A #wasmtime_instance_t, pre-instantiation, that is ready to be
/// instantiated.
///
/// Must be deleted using #wasmtime_instance_pre_delete.
///
/// For more information see the Rust documentation:
/// https://docs.wasmtime.dev/api/wasmtime/struct.InstancePre.html
typedef wasmtime_instance_pre_t = wasmtime_instance_pre;

final class wasmtime_linker extends ffi.Opaque {}

/// \typedef wasmtime_linker_t
/// \brief Alias to #wasmtime_linker
///
/// \struct #wasmtime_linker
/// \brief Object used to conveniently link together and instantiate wasm
/// modules.
///
/// This type corresponds to the `wasmtime::Linker` type in Rust. This
/// type is intended to make it easier to manage a set of modules that link
/// together, or to make it easier to link WebAssembly modules to WASI.
///
/// A #wasmtime_linker_t is a higher level way to instantiate a module than
/// #wasm_instance_new since it works at the "string" level of imports rather
/// than requiring 1:1 mappings.
typedef wasmtime_linker_t = wasmtime_linker;

final class wasmtime_guestprofiler extends ffi.Opaque {}

/// \brief Collects basic profiling data for a single WebAssembly guest.
///
/// To use this, youâ€™ll need to arrange to call #wasmtime_guestprofiler_sample at
/// regular intervals while the guest is on the stack. The most straightforward
/// way to do that is to call it from a callback registered with
/// #wasmtime_store_epoch_deadline_callback.
///
/// For more information see the Rust documentation at:
/// https://docs.wasmtime.dev/api/wasmtime/struct.GuestProfiler.html
typedef wasmtime_guestprofiler_t = wasmtime_guestprofiler;

/// \typedef wasmtime_guestprofiler_modules_t
/// \brief Alias to #wasmtime_guestprofiler_modules
///
/// \struct #wasmtime_guestprofiler_modules
/// \brief Tuple of name and module for passing into #wasmtime_guestprofiler_new.
final class wasmtime_guestprofiler_modules extends ffi.Struct {
  /// !< Name recorded in the profile.
  external ffi.Pointer<wasm_name_t> name;

  /// !< Module that is being allowed to appear in captured stack trace.
  external ffi.Pointer<wasmtime_module_t> mod;
}

typedef wasmtime_guestprofiler_modules_t = wasmtime_guestprofiler_modules;

/// \brief Code of an instruction trap.
///
/// See #wasmtime_trap_code_enum for possible values.
typedef wasmtime_trap_code_t = ffi.Uint8;
typedef Dartwasmtime_trap_code_t = int;

/// \brief Trap codes for instruction traps.
enum wasmtime_trap_code_enum {
  /// The current stack space was exhausted.
  WASMTIME_TRAP_CODE_STACK_OVERFLOW(0),

  /// An out-of-bounds memory access.
  WASMTIME_TRAP_CODE_MEMORY_OUT_OF_BOUNDS(1),

  /// A wasm atomic operation was presented with a not-naturally-aligned
  /// linear-memory address.
  WASMTIME_TRAP_CODE_HEAP_MISALIGNED(2),

  /// An out-of-bounds access to a table.
  WASMTIME_TRAP_CODE_TABLE_OUT_OF_BOUNDS(3),

  /// Indirect call to a null table entry.
  WASMTIME_TRAP_CODE_INDIRECT_CALL_TO_NULL(4),

  /// Signature mismatch on indirect call.
  WASMTIME_TRAP_CODE_BAD_SIGNATURE(5),

  /// An integer arithmetic operation caused an overflow.
  WASMTIME_TRAP_CODE_INTEGER_OVERFLOW(6),

  /// An integer division by zero.
  WASMTIME_TRAP_CODE_INTEGER_DIVISION_BY_ZERO(7),

  /// Failed float-to-int conversion.
  WASMTIME_TRAP_CODE_BAD_CONVERSION_TO_INTEGER(8),

  /// Code that was supposed to have been unreachable was reached.
  WASMTIME_TRAP_CODE_UNREACHABLE_CODE_REACHED(9),

  /// Execution has potentially run too long and may be interrupted.
  WASMTIME_TRAP_CODE_INTERRUPT(10),

  /// When the `component-model` feature is enabled this trap represents a
  /// function that was `canon lift`'d, then `canon lower`'d, then called.
  /// This combination of creation of a function in the component model
  /// generates a function that always traps and, when called, produces this
  /// flavor of trap.
  WASMTIME_TRAP_CODE_ALWAYS_TRAP_ADAPTER(11),

  /// Execution has run out of the configured fuel amount.
  WASMTIME_TRAP_CODE_OUT_OF_FUEL(12),

  /// Used to indicate that a trap was raised by atomic wait operations on non
  /// shared memory.
  WASMTIME_TRAP_CODE_ATOMIC_WAIT_NON_SHARED_MEMORY(13),

  /// Call to a null reference.
  WASMTIME_TRAP_CODE_NULL_REFERENCE(14),

  /// Attempt to access beyond the bounds of an array.
  WASMTIME_TRAP_CODE_ARRAY_OUT_OF_BOUNDS(15),

  /// Attempted an allocation that was too large to succeed.
  WASMTIME_TRAP_CODE_ALLOCATION_TOO_LARGE(16),

  /// Attempted to cast a reference to a type that it is not an instance of.
  WASMTIME_TRAP_CODE_CAST_FAILURE(17),

  /// When the `component-model` feature is enabled this trap represents a
  /// scenario where one component tried to call another component but it
  /// would have violated the reentrance rules of the component model,
  /// triggering a trap instead.
  WASMTIME_TRAP_CODE_CANNOT_ENTER_COMPONENT(18),

  /// Async-lifted export failed to produce a result by calling `task.return`
  /// before returning `STATUS_DONE` and/or after all host tasks completed.
  WASMTIME_TRAP_CODE_NO_ASYNC_RESULT(19),

  /// A Pulley opcode was executed at runtime when the opcode was disabled at
  /// compile time.
  WASMTIME_TRAP_CODE_DISABLED_OPCODE(20);

  final int value;
  const wasmtime_trap_code_enum(this.value);

  static wasmtime_trap_code_enum fromValue(int value) => switch (value) {
    0 => WASMTIME_TRAP_CODE_STACK_OVERFLOW,
    1 => WASMTIME_TRAP_CODE_MEMORY_OUT_OF_BOUNDS,
    2 => WASMTIME_TRAP_CODE_HEAP_MISALIGNED,
    3 => WASMTIME_TRAP_CODE_TABLE_OUT_OF_BOUNDS,
    4 => WASMTIME_TRAP_CODE_INDIRECT_CALL_TO_NULL,
    5 => WASMTIME_TRAP_CODE_BAD_SIGNATURE,
    6 => WASMTIME_TRAP_CODE_INTEGER_OVERFLOW,
    7 => WASMTIME_TRAP_CODE_INTEGER_DIVISION_BY_ZERO,
    8 => WASMTIME_TRAP_CODE_BAD_CONVERSION_TO_INTEGER,
    9 => WASMTIME_TRAP_CODE_UNREACHABLE_CODE_REACHED,
    10 => WASMTIME_TRAP_CODE_INTERRUPT,
    11 => WASMTIME_TRAP_CODE_ALWAYS_TRAP_ADAPTER,
    12 => WASMTIME_TRAP_CODE_OUT_OF_FUEL,
    13 => WASMTIME_TRAP_CODE_ATOMIC_WAIT_NON_SHARED_MEMORY,
    14 => WASMTIME_TRAP_CODE_NULL_REFERENCE,
    15 => WASMTIME_TRAP_CODE_ARRAY_OUT_OF_BOUNDS,
    16 => WASMTIME_TRAP_CODE_ALLOCATION_TOO_LARGE,
    17 => WASMTIME_TRAP_CODE_CAST_FAILURE,
    18 => WASMTIME_TRAP_CODE_CANNOT_ENTER_COMPONENT,
    19 => WASMTIME_TRAP_CODE_NO_ASYNC_RESULT,
    20 => WASMTIME_TRAP_CODE_DISABLED_OPCODE,
    _ => throw ArgumentError(
      'Unknown value for wasmtime_trap_code_enum: $value',
    ),
  };
}

typedef wasmtime_func_async_continuation_callback_tFunction =
    ffi.Bool Function(ffi.Pointer<ffi.Void> env);
typedef Dartwasmtime_func_async_continuation_callback_tFunction =
    bool Function(ffi.Pointer<ffi.Void> env);

/// The callback to determine a continuation's current state.
///
/// Return true if the host call has completed, otherwise false will
/// continue to yield WebAssembly execution.
typedef wasmtime_func_async_continuation_callback_t =
    ffi.Pointer<
      ffi.NativeFunction<wasmtime_func_async_continuation_callback_tFunction>
    >;

/// A continuation for the current state of the host function's execution.
final class wasmtime_async_continuation_t extends ffi.Struct {
  /// Callback for if the async function has completed.
  external wasmtime_func_async_continuation_callback_t callback;

  /// User-provided argument to pass to the callback.
  external ffi.Pointer<ffi.Void> env;

  /// A finalizer for the user-provided *env
  external ffi.Pointer<
    ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>
  >
  finalizer;
}

typedef wasmtime_func_async_callback_tFunction =
    ffi.Void Function(
      ffi.Pointer<ffi.Void> env,
      ffi.Pointer<wasmtime_caller_t> caller,
      ffi.Pointer<wasmtime_val_t> args,
      ffi.Size nargs,
      ffi.Pointer<wasmtime_val_t> results,
      ffi.Size nresults,
      ffi.Pointer<ffi.Pointer<wasm_trap_t>> trap_ret,
      ffi.Pointer<wasmtime_async_continuation_t> continuation_ret,
    );
typedef Dartwasmtime_func_async_callback_tFunction =
    void Function(
      ffi.Pointer<ffi.Void> env,
      ffi.Pointer<wasmtime_caller_t> caller,
      ffi.Pointer<wasmtime_val_t> args,
      int nargs,
      ffi.Pointer<wasmtime_val_t> results,
      int nresults,
      ffi.Pointer<ffi.Pointer<wasm_trap_t>> trap_ret,
      ffi.Pointer<wasmtime_async_continuation_t> continuation_ret,
    );

/// \brief Callback signature for #wasmtime_linker_define_async_func.
///
/// This is a host function that returns a continuation to be called later.
///
/// All the arguments to this function will be kept alive until the continuation
/// returns that it has errored or has completed.
///
/// \param env user-provided argument passed to
/// #wasmtime_linker_define_async_func
/// \param caller a temporary object that can only be used during this function
/// call. Used to acquire #wasmtime_context_t or caller's state
/// \param args the arguments provided to this function invocation
/// \param nargs how many arguments are provided
/// \param results where to write the results of this function
/// \param nresults how many results must be produced
/// \param trap_ret if assigned a not `NULL` value then the called
/// function will trap with the returned error. Note that ownership of
/// trap is transferred to wasmtime.
/// \param continuation_ret the returned continuation
/// that determines when the async function has completed executing.
///
/// Only supported for async stores.
///
/// See #wasmtime_func_callback_t for more information.
typedef wasmtime_func_async_callback_t =
    ffi.Pointer<ffi.NativeFunction<wasmtime_func_async_callback_tFunction>>;

final class wasmtime_call_future extends ffi.Opaque {}

/// \brief The structure representing a asynchronously running function.
///
/// This structure is always owned by the caller and must be deleted using
/// #wasmtime_call_future_delete.
///
/// Functions that return this type require that the parameters to the function
/// are unmodified until this future is destroyed.
typedef wasmtime_call_future_t = wasmtime_call_future;
typedef wasmtime_stack_memory_get_callback_tFunction =
    ffi.Pointer<ffi.Uint8> Function(
      ffi.Pointer<ffi.Void> env,
      ffi.Pointer<ffi.Size> out_len,
    );

/// A callback to get the top of the stack address and the length of the stack,
/// excluding guard pages.
///
/// For more information about the parameters see the Rust documentation at
/// https://docs.wasmtime.dev/api/wasmtime/trait.StackMemory.html
typedef wasmtime_stack_memory_get_callback_t =
    ffi.Pointer<
      ffi.NativeFunction<wasmtime_stack_memory_get_callback_tFunction>
    >;

/// A Stack instance created from a #wasmtime_new_stack_memory_callback_t.
///
/// For more information see the Rust documentation at
/// https://docs.wasmtime.dev/api/wasmtime/trait.StackMemory.html
final class wasmtime_stack_memory_t extends ffi.Struct {
  /// User provided value to be passed to get_memory and grow_memory
  external ffi.Pointer<ffi.Void> env;

  /// Callback to get the memory and size of this LinearMemory
  external wasmtime_stack_memory_get_callback_t get_stack_memory;

  /// An optional finalizer for env
  external ffi.Pointer<
    ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>
  >
  finalizer;
}

typedef wasmtime_new_stack_memory_callback_tFunction =
    ffi.Pointer<wasmtime_error_t> Function(
      ffi.Pointer<ffi.Void> env,
      ffi.Size size,
      ffi.Bool zeroed,
      ffi.Pointer<wasmtime_stack_memory_t> stack_ret,
    );
typedef Dartwasmtime_new_stack_memory_callback_tFunction =
    ffi.Pointer<wasmtime_error_t> Function(
      ffi.Pointer<ffi.Void> env,
      int size,
      bool zeroed,
      ffi.Pointer<wasmtime_stack_memory_t> stack_ret,
    );

/// A callback to create a new StackMemory from the specified parameters.
///
/// The result should be written to `stack_ret` and wasmtime will own the values
/// written into that struct.
///
/// This callback must be thread-safe.
///
/// For more information about the parameters see the Rust documentation at
/// https://docs.wasmtime.dev/api/wasmtime/trait.StackCreator.html#tymethod.new_stack
typedef wasmtime_new_stack_memory_callback_t =
    ffi.Pointer<
      ffi.NativeFunction<wasmtime_new_stack_memory_callback_tFunction>
    >;

/// A representation of custom stack creator.
///
/// For more information see the Rust documentation at
/// https://docs.wasmtime.dev/api/wasmtime/trait.StackCreator.html
final class wasmtime_stack_creator_t extends ffi.Struct {
  /// User provided value to be passed to new_stack
  external ffi.Pointer<ffi.Void> env;

  /// The callback to create a new stack, must be thread safe
  external wasmtime_new_stack_memory_callback_t new_stack;

  /// An optional finalizer for env.
  external ffi.Pointer<
    ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>
  >
  finalizer;
}

final class wasmtime_component_t extends ffi.Opaque {}

final class wasmtime_component_export_index_t extends ffi.Opaque {}

/// \brief Discriminant used in #wasmtime_component_val_t::kind
typedef wasmtime_component_valkind_t = ffi.Uint8;
typedef Dartwasmtime_component_valkind_t = int;

/// \brief A vec of a type
final class wasmtime_component_vallist extends ffi.Struct {
  /// Length of the vec
  @ffi.Size()
  external int size;

  external ffi.Pointer<wasmtime_component_val> data;
}

typedef wasmtime_component_vallist_t = wasmtime_component_vallist;
typedef wasmtime_component_val_t = wasmtime_component_val;

/// \brief A pair of a name and a value that represents one entry in a value
/// with kind #WASMTIME_COMPONENT_RECORD
final class wasmtime_component_valrecord_entry extends ffi.Struct {
  /// The name of this entry
  external wasm_name_t name;

  /// The value of this entry
  external wasmtime_component_val_t val;
}

final class wasmtime_component_valrecord extends ffi.Struct {
  @ffi.Size()
  external int size;

  external ffi.Pointer<wasmtime_component_valrecord_entry> data;
}

typedef wasmtime_component_valrecord_t = wasmtime_component_valrecord;

final class wasmtime_component_valtuple extends ffi.Struct {
  @ffi.Size()
  external int size;

  external ffi.Pointer<wasmtime_component_val> data;
}

typedef wasmtime_component_valtuple_t = wasmtime_component_valtuple;

/// Represents a variant type
final class wasmtime_component_valvariant_t extends ffi.Struct {
  /// The discriminant of the variant
  external wasm_name_t discriminant;

  /// The payload of the variant
  external ffi.Pointer<wasmtime_component_val> val;
}

/// Represents a result type
final class wasmtime_component_valresult_t extends ffi.Struct {
  /// The discriminant of the result
  @ffi.Bool()
  external bool is_ok;

  /// The 'ok' value if #wasmtime_component_valresult_t::is_ok is `true`, else
  /// the 'err' value
  external ffi.Pointer<wasmtime_component_val> val;
}

final class wasmtime_component_valflags extends ffi.Struct {
  @ffi.Size()
  external int size;

  external ffi.Pointer<wasm_name_t> data;
}

typedef wasmtime_component_valflags_t = wasmtime_component_valflags;

/// \brief Represents possible runtime values which a component function can
/// either consume or produce
final class wasmtime_component_valunion_t extends ffi.Union {
  /// Field used if #wasmtime_component_val_t::kind is #WASMTIME_COMPONENT_BOOL
  @ffi.Bool()
  external bool boolean;

  /// Field used if #wasmtime_component_val_t::kind is #WASMTIME_COMPONENT_S8
  @ffi.Int8()
  external int s8;

  /// Field used if #wasmtime_component_val_t::kind is #WASMTIME_COMPONENT_U8
  @ffi.Uint8()
  external int u8;

  /// Field used if #wasmtime_component_val_t::kind is #WASMTIME_COMPONENT_S16
  @ffi.Int16()
  external int s16;

  /// Field used if #wasmtime_component_val_t::kind is #WASMTIME_COMPONENT_U16
  @ffi.Uint16()
  external int u16;

  /// Field used if #wasmtime_component_val_t::kind is #WASMTIME_COMPONENT_S32
  @ffi.Int32()
  external int s32;

  /// Field used if #wasmtime_component_val_t::kind is #WASMTIME_COMPONENT_U32
  @ffi.Uint32()
  external int u32;

  /// Field used if #wasmtime_component_val_t::kind is #WASMTIME_COMPONENT_S64
  @ffi.Int64()
  external int s64;

  /// Field used if #wasmtime_component_val_t::kind is #WASMTIME_COMPONENT_U64
  @ffi.Uint64()
  external int u64;

  /// Field used if #wasmtime_component_val_t::kind is #WASMTIME_COMPONENT_F32
  @float32_t()
  external double f32;

  /// Field used if #wasmtime_component_val_t::kind is #WASMTIME_COMPONENT_F64
  @float64_t()
  external double f64;

  /// Field used if #wasmtime_component_val_t::kind is #WASMTIME_COMPONENT_CHAR
  @ffi.Uint32()
  external int character;

  /// Field used if #wasmtime_component_val_t::kind is
  /// #WASMTIME_COMPONENT_STRING
  external wasm_name_t string;

  /// Field used if #wasmtime_component_val_t::kind is #WASMTIME_COMPONENT_LIST
  external wasmtime_component_vallist_t list;

  /// Field used if #wasmtime_component_val_t::kind is
  /// #WASMTIME_COMPONENT_RECORD
  external wasmtime_component_valrecord_t record;

  /// Field used if #wasmtime_component_val_t::kind is #WASMTIME_COMPONENT_TUPLE
  external wasmtime_component_valtuple_t tuple;

  /// Field used if #wasmtime_component_val_t::kind is
  /// #WASMTIME_COMPONENT_VARIANT
  external wasmtime_component_valvariant_t variant;

  /// Field used if #wasmtime_component_val_t::kind is #WASMTIME_COMPONENT_ENUM
  external wasm_name_t enumeration;

  /// Field used if #wasmtime_component_val_t::kind is
  /// #WASMTIME_COMPONENT_OPTION
  external ffi.Pointer<wasmtime_component_val> option;

  /// Field used if #wasmtime_component_val_t::kind is
  /// #WASMTIME_COMPONENT_RESULT
  external wasmtime_component_valresult_t result;

  /// Field used if #wasmtime_component_val_t::kind is #WASMTIME_COMPONENT_FLAGS
  external wasmtime_component_valflags_t flags;
}

/// \brief Represents possible runtime values which a component function can
/// either consume or produce
final class wasmtime_component_val extends ffi.Struct {
  /// The type discriminant
  @wasmtime_component_valkind_t()
  external int kind;

  /// Value of type \ref kind
  external wasmtime_component_valunion_t of;
}

typedef wasmtime_component_valrecord_entry_t =
    wasmtime_component_valrecord_entry;

final class UnnamedStruct$2 extends ffi.Struct {
  /// Internal identifier of what store this belongs to, never zero.
  @ffi.Uint64()
  external int store_id;

  /// Private internal wasmtime information.
  @ffi.Uint32()
  external int __private1;
}

/// \brief Representation of a function in Wasmtime.
///
/// Functions in Wasmtime are represented as an index into a store and don't
/// have any data or destructor associated with the value. Functions cannot
/// interoperate between #wasmtime_store_t instances and if the wrong function
/// is passed to the wrong store then it may trigger an assertion to abort the
/// process.
final class wasmtime_component_func extends ffi.Struct {
  external UnnamedStruct$2 unnamed;

  /// Private internal wasmtime information.
  @ffi.Uint32()
  external int __private2;
}

typedef wasmtime_component_func_t = wasmtime_component_func;

/// \brief Representation of a instance in Wasmtime.
///
/// Instances are represented with a 64-bit identifying integer in Wasmtime.
/// They do not have any destructor associated with them. Instances cannot
/// interoperate between #wasmtime_store_t instances and if the wrong instance
/// is passed to the wrong store then it may trigger an assertion to abort the
/// process.
final class wasmtime_component_instance extends ffi.Struct {
  /// Internal identifier of what store this belongs to, never zero.
  @ffi.Uint64()
  external int store_id;

  /// Internal index within the store.
  @ffi.Uint32()
  external int __private;
}

typedef wasmtime_component_instance_t = wasmtime_component_instance;

final class wasmtime_component_linker_t extends ffi.Opaque {}

final class wasmtime_component_linker_instance_t extends ffi.Opaque {}

typedef wasmtime_component_func_callback_tFunction =
    ffi.Pointer<wasmtime_error_t> Function(
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<wasmtime_context_t>,
      ffi.Pointer<wasmtime_component_val_t>,
      ffi.Size,
      ffi.Pointer<wasmtime_component_val_t>,
      ffi.Size,
    );
typedef Dartwasmtime_component_func_callback_tFunction =
    ffi.Pointer<wasmtime_error_t> Function(
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<wasmtime_context_t>,
      ffi.Pointer<wasmtime_component_val_t>,
      int,
      ffi.Pointer<wasmtime_component_val_t>,
      int,
    );

/// Type of the callback used in #wasmtime_component_linker_instance_add_func
typedef wasmtime_component_func_callback_t =
    ffi.Pointer<ffi.NativeFunction<wasmtime_component_func_callback_tFunction>>;

const int NULL = 0;

const int _STDINT_H = 1;

const int _FEATURES_H = 1;

const int _DEFAULT_SOURCE = 1;

const int __GLIBC_USE_ISOC2Y = 1;

const int __GLIBC_USE_ISOC23 = 1;

const int __USE_ISOC11 = 1;

const int __USE_ISOC99 = 1;

const int __USE_ISOC95 = 1;

const int _POSIX_SOURCE = 1;

const int _POSIX_C_SOURCE = 200809;

const int __USE_POSIX = 1;

const int __USE_POSIX2 = 1;

const int __USE_POSIX199309 = 1;

const int __USE_POSIX199506 = 1;

const int __USE_XOPEN2K = 1;

const int __USE_XOPEN2K8 = 1;

const int _ATFILE_SOURCE = 1;

const int __WORDSIZE = 64;

const int __WORDSIZE_TIME64_COMPAT32 = 1;

const int __SYSCALL_WORDSIZE = 64;

const int __TIMESIZE = 64;

const int __USE_TIME_BITS64 = 1;

const int __USE_MISC = 1;

const int __USE_ATFILE = 1;

const int __USE_FORTIFY_LEVEL = 0;

const int __GLIBC_USE_DEPRECATED_GETS = 0;

const int __GLIBC_USE_DEPRECATED_SCANF = 0;

const int __GLIBC_USE_C23_STRTOL = 1;

const int _STDC_PREDEF_H = 1;

const int __STDC_IEC_559__ = 1;

const int __STDC_IEC_60559_BFP__ = 201404;

const int __STDC_IEC_559_COMPLEX__ = 1;

const int __STDC_IEC_60559_COMPLEX__ = 201404;

const int __STDC_ISO_10646__ = 201706;

const int __GNU_LIBRARY__ = 6;

const int __GLIBC__ = 2;

const int __GLIBC_MINOR__ = 42;

const int _SYS_CDEFS_H = 1;

const int __THROW = 1;

const int __THROWNL = 1;

const int __glibc_c99_flexarr_available = 1;

const int __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI = 0;

const int __HAVE_GENERIC_SELECTION = 0;

const int __GLIBC_USE_LIB_EXT2 = 1;

const int __GLIBC_USE_IEC_60559_BFP_EXT = 1;

const int __GLIBC_USE_IEC_60559_BFP_EXT_C23 = 1;

const int __GLIBC_USE_IEC_60559_EXT = 1;

const int __GLIBC_USE_IEC_60559_FUNCS_EXT = 1;

const int __GLIBC_USE_IEC_60559_FUNCS_EXT_C23 = 1;

const int __GLIBC_USE_IEC_60559_TYPES_EXT = 1;

const int _BITS_TYPES_H = 1;

const int _BITS_TYPESIZES_H = 1;

const int __OFF_T_MATCHES_OFF64_T = 1;

const int __INO_T_MATCHES_INO64_T = 1;

const int __RLIM_T_MATCHES_RLIM64_T = 1;

const int __STATFS_MATCHES_STATFS64 = 1;

const int __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64 = 1;

const int __FD_SETSIZE = 1024;

const int _BITS_TIME64_H = 1;

const int _BITS_WCHAR_H = 1;

const int __WCHAR_MAX = 2147483647;

const int __WCHAR_MIN = -2147483648;

const int _BITS_STDINT_INTN_H = 1;

const int _BITS_STDINT_UINTN_H = 1;

const int _BITS_STDINT_LEAST_H = 1;

const int INT8_MIN = -128;

const int INT16_MIN = -32768;

const int INT32_MIN = -2147483648;

const int INT64_MIN = -9223372036854775808;

const int INT8_MAX = 127;

const int INT16_MAX = 32767;

const int INT32_MAX = 2147483647;

const int INT64_MAX = 9223372036854775807;

const int UINT8_MAX = 255;

const int UINT16_MAX = 65535;

const int UINT32_MAX = 4294967295;

const int UINT64_MAX = -1;

const int INT_LEAST8_MIN = -128;

const int INT_LEAST16_MIN = -32768;

const int INT_LEAST32_MIN = -2147483648;

const int INT_LEAST64_MIN = -9223372036854775808;

const int INT_LEAST8_MAX = 127;

const int INT_LEAST16_MAX = 32767;

const int INT_LEAST32_MAX = 2147483647;

const int INT_LEAST64_MAX = 9223372036854775807;

const int UINT_LEAST8_MAX = 255;

const int UINT_LEAST16_MAX = 65535;

const int UINT_LEAST32_MAX = 4294967295;

const int UINT_LEAST64_MAX = -1;

const int INT_FAST8_MIN = -128;

const int INT_FAST16_MIN = -9223372036854775808;

const int INT_FAST32_MIN = -9223372036854775808;

const int INT_FAST64_MIN = -9223372036854775808;

const int INT_FAST8_MAX = 127;

const int INT_FAST16_MAX = 9223372036854775807;

const int INT_FAST32_MAX = 9223372036854775807;

const int INT_FAST64_MAX = 9223372036854775807;

const int UINT_FAST8_MAX = 255;

const int UINT_FAST16_MAX = -1;

const int UINT_FAST32_MAX = -1;

const int UINT_FAST64_MAX = -1;

const int INTPTR_MIN = -9223372036854775808;

const int INTPTR_MAX = 9223372036854775807;

const int UINTPTR_MAX = -1;

const int INTMAX_MIN = -9223372036854775808;

const int INTMAX_MAX = 9223372036854775807;

const int UINTMAX_MAX = -1;

const int PTRDIFF_MIN = -9223372036854775808;

const int PTRDIFF_MAX = 9223372036854775807;

const int SIG_ATOMIC_MIN = -2147483648;

const int SIG_ATOMIC_MAX = 2147483647;

const int SIZE_MAX = -1;

const int WCHAR_MIN = -2147483648;

const int WCHAR_MAX = 2147483647;

const int WINT_MIN = 0;

const int WINT_MAX = 4294967295;

const int __bool_true_false_are_defined = 1;

const int true$ = 1;

const int false$ = 0;

const int _STRING_H = 1;

const int _BITS_TYPES_LOCALE_T_H = 1;

const int _BITS_TYPES___LOCALE_T_H = 1;

const int _STRINGS_H = 1;

const int _ASSERT_H = 1;

const int WASMTIME_UPDATE_DEADLINE_CONTINUE = 0;

const int WASMTIME_UPDATE_DEADLINE_YIELD = 1;

const int WASMTIME_EXTERN_FUNC = 0;

const int WASMTIME_EXTERN_GLOBAL = 1;

const int WASMTIME_EXTERN_TABLE = 2;

const int WASMTIME_EXTERN_MEMORY = 3;

const int WASMTIME_EXTERN_SHAREDMEMORY = 4;

const int __alignas_is_defined = 1;

const int __alignof_is_defined = 1;

const int WASMTIME_I32 = 0;

const int WASMTIME_I64 = 1;

const int WASMTIME_F32 = 2;

const int WASMTIME_F64 = 3;

const int WASMTIME_V128 = 4;

const int WASMTIME_FUNCREF = 5;

const int WASMTIME_EXTERNREF = 6;

const int WASMTIME_ANYREF = 7;

const int WASMTIME_COMPONENT_BOOL = 0;

const int WASMTIME_COMPONENT_S8 = 1;

const int WASMTIME_COMPONENT_U8 = 2;

const int WASMTIME_COMPONENT_S16 = 3;

const int WASMTIME_COMPONENT_U16 = 4;

const int WASMTIME_COMPONENT_S32 = 5;

const int WASMTIME_COMPONENT_U32 = 6;

const int WASMTIME_COMPONENT_S64 = 7;

const int WASMTIME_COMPONENT_U64 = 8;

const int WASMTIME_COMPONENT_F32 = 9;

const int WASMTIME_COMPONENT_F64 = 10;

const int WASMTIME_COMPONENT_CHAR = 11;

const int WASMTIME_COMPONENT_STRING = 12;

const int WASMTIME_COMPONENT_LIST = 13;

const int WASMTIME_COMPONENT_RECORD = 14;

const int WASMTIME_COMPONENT_TUPLE = 15;

const int WASMTIME_COMPONENT_VARIANT = 16;

const int WASMTIME_COMPONENT_ENUM = 17;

const int WASMTIME_COMPONENT_OPTION = 18;

const int WASMTIME_COMPONENT_RESULT = 19;

const int WASMTIME_COMPONENT_FLAGS = 20;

const String WASMTIME_VERSION = '38.0.3';

const int WASMTIME_VERSION_MAJOR = 38;

const int WASMTIME_VERSION_MINOR = 0;

const int WASMTIME_VERSION_PATCH = 3;
